import chalk from 'chalk'
import inquirer from 'inquirer'
import simpleGit, { SimpleGit } from 'simple-git'
import fs from 'fs'
import path from 'path'
import { exec } from 'child_process'
import {
  displayTitle,
  getDescriptionFromTitle,
  toKebabCase,
  capitalize,
  caseEnv,
  isPatchOrBackport,
  validateBranches,
  bumpNpmVersionPatch,
} from '../utils/helperFunctions'

export const execShellCommand = (cmd: string): Promise<string> => {
  return new Promise((resolve, reject) => {
    exec(cmd, (error, stdout, stderr) => {
      if (error) {
        reject(error)
      } else if (stderr) {
        reject(stderr)
      } else {
        resolve(stdout)
      }
    })
  })
}

export const main = async (commitId: string) => {
  const git: SimpleGit = simpleGit()

  displayTitle()

  // Get the commit title
  let commitTitle: string
  try {
    commitTitle = await git.raw(['log', '--format=%s', '-n', '1', commitId])
  } catch (error) {
    console.error(
      chalk.red(
        'Failed to get commit title. Please ensure the commit ID is correct.'
      )
    )
    process.exit(1)
  }

  let descriptionForPR = getDescriptionFromTitle(commitTitle)

  console.log('\nThis commit will be cherry-picked:')
  console.log(commitTitle.trim())

  // Confirm or edit the description
  const { validTitle } = await inquirer.prompt([
    {
      type: 'confirm',
      name: 'validTitle',
      message: `Correct description below?\n${descriptionForPR}`,
      default: true,
    },
  ])

  if (!validTitle) {
    const { newDescription } = await inquirer.prompt([
      {
        type: 'input',
        name: 'newDescription',
        message: 'Copy or write the description (should match commit above):',
      },
    ])
    descriptionForPR = newDescription
  }

  // Get origin and destination branches
  const { originBranch } = await inquirer.prompt([
    {
      type: 'list',
      name: 'originBranch',
      message: 'Origin Branch',
      choices: ['develop', 'qa', 'uat', 'prod'],
    },
  ])

  const { destinationBranches } = await inquirer.prompt([
    {
      type: 'checkbox',
      name: 'destinationBranches',
      message: 'Destination Branches',
      choices: ['develop', 'qa', 'uat', 'prod'],
    },
  ])

  const kebabDescriptionForPR = toKebabCase(descriptionForPR)

  // Final confirmation
  console.log(chalk.yellow('\nFinal confirmation:'))
  const { doIt } = await inquirer.prompt([
    {
      type: 'confirm',
      name: 'doIt',
      message: `${originBranch} -> ${destinationBranches.join(' ')}`,
      default: false,
    },
  ])

  if (!doIt) {
    console.log(chalk.red('\nAborting...'))
    process.exit(1)
  }

  for (const branch of destinationBranches) {
    if (!validateBranches(originBranch, branch)) {
      console.log(
        chalk.red(`\nSkipping invalid branch: ${originBranch} -> ${branch}!`)
      )
      continue
    }

    const action = isPatchOrBackport(originBranch, branch)
    const capitalizedAction = capitalize(action)
    const newBranchName = `${action}/from-${originBranch}-to-${branch}/${kebabDescriptionForPR}`
    const parsedBranch = branch === 'prod' ? 'master' : branch

    console.log('')
    console.log(
      chalk.cyan(
        `Creating ${action} for ${caseEnv(originBranch)} -> ${caseEnv(branch)}...`
      )
    )

    // Checkout branch, pull, create new branch
    try {
      await git.checkout(parsedBranch)
      await git.pull('origin', parsedBranch)
      await git.checkoutLocalBranch(newBranchName)
    } catch (error) {
      console.error(chalk.red(`Failed to prepare branch ${newBranchName}.`))
      process.exit(1)
    }

    // Cherry-pick the commit
    try {
      await git.raw(['cherry-pick', commitId])
    } catch (error) {
      console.error(
        chalk.red('Cherry-pick failed, please resolve conflicts manually.')
      )
      process.exit(1)
    }

    // Bump npm version
    await bumpNpmVersionPatch(git, parsedBranch)

    // Push the new branch
    try {
      await git.push('origin', newBranchName)
    } catch (error) {
      console.error(chalk.red(`Failed to push branch ${newBranchName}.`))
      process.exit(1)
    }

    // Create PR using gh CLI
    const prTitle = `${capitalizedAction} | ${caseEnv(
      originBranch
    )} to ${caseEnv(branch)} | ${commitTitle.trim()}`
    const prBody = `${capitalizedAction} PR automatically generated by PatchPortâ„¢`

    try {
      const prCommand = `gh pr create --title "${prTitle}" --body "${prBody}" --base "${parsedBranch}" --head "${newBranchName}" --label "${capitalizedAction}"`
      await execShellCommand(prCommand)
    } catch (error) {
      console.error(chalk.red('Failed to create pull request using gh CLI.'))
      console.error(error)
    }
  }

  // Return to a safe branch
  try {
    await git.checkout('qa')
  } catch (error) {
    console.error(chalk.red('Failed to checkout to qa branch.'))
  }

  console.log(
    chalk.green('\nAll done! Go check your repository pull requests on GitHub.')
  )
  process.exit(0)
}
